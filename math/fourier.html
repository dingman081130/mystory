<script src="./vue.js"></script>
<div id="app">
    <canvas id="myCanvas" style="border:1px solid #000000;"></canvas>
    <span>展示级数: {{ show }}</span>
    <button v-on:click="iincrease">↑</button>
    <button v-on:click="ddecrease">↓</button>
    <button v-on:click="ppause" v-if="pause">Continue</button>
    <button v-on:click="ppause" v-else>Pause</button>
    <button v-on:click="sstep">Step</button>
</div>
<script>
var app = new Vue({
    el: '#app',
    data: {
        canvas : { width :1000, height : 0 },
        radius : 50,
        step : 0.5,
        origin : { x : 0, y : 0 },
        wavelenght : 0,
        boundary : 0,
        circles : [],
        colors : ['#bf616a', '#a3be8c', '#eccb8b', '#81a1c1', '#88c0d0'],
        series : 5,
        show : 3,
        ctx : '',
        pause : false,
    },
    methods : {
        init : function(e) {
            this.boundary = this.origin.x = 0;
            for (var i = 0; i < this.series; i ++) {
                this.circles[i] = {
                    radius : this.radius / (i + 1),    // 振幅
                    center : {},                            // 圆心
                    frequence:  1 + 2 * i,                  // 频率
                    theta:0,                                // 初相
                    intersect:{},                           // 交点
                    curve:[],                               // 曲线
                    color:this.colors[i],                   // 颜色
                    cnt:0,                                  // 计数
                };
                this.boundary += this.circles[i].radius;
                this.origin.x += this.circles[i].radius;
            }
            this.origin.x += 20;
            this.origin.y = this.origin.x;
            this.canvas.height = 2 * this.origin.y
            this.boundary += this.origin.x;
            this.boundary += 50;
            this.wavelenght = parseInt((this.canvas.width - this.boundary) / this.step) - 20;
            
            this.ctx = document.getElementById("myCanvas").getContext("2d");
            this.ctx.canvas.width  = this.canvas.width;  //window.innerWidth - 20;
            this.ctx.canvas.height = this.canvas.height;
        },
        iincrease : function() {
            if (this.show < this.series) {
                this.show ++;
            }
        },
        ddecrease : function() {
            if (this.show > 1) {
                this.show --;
            }
            this.circles[this.show].curve = [];
            this.circles[this.show].cnt = 0;
        },
        ppause : function() {
            this.pause = !this.pause;
        },
        sstep : function() {
            this.pause = true;
            this.recompute();
            this.redraw();
        },
        recompute : function(e) {
            var current_center = this.origin;
            for (var i = 0; i < this.circles.length; i ++) {
                this.circles[i].center = current_center;
                this.circles[i].intersect = {
                    x : current_center.x + Math.cos(this.circles[i].theta) * this.circles[i].radius,
                    y : current_center.y - Math.sin(this.circles[i].theta) * this.circles[i].radius,
                };
                if (i < this.show ) {
                    for (var j = 0; j < this.circles[i].curve.length; j ++) {
                        this.circles[i].curve[j].x += this.step;
                    }
                    this.circles[i].curve[this.circles[i].cnt % this.wavelenght] = {x:this.boundary, y:this.circles[i].intersect.y};
                    this.circles[i].cnt ++;
                }
                this.circles[i].theta += Math.PI / 180 * this.circles[i].frequence;
                current_center = this.circles[i].intersect;
            }
        },
        redraw : function(e) {
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            for (var i = 0; i < this.show; i ++) {
                this.ctx.beginPath();
                this.ctx.fillStyle = this.circles[i].color;
                this.ctx.strokeStyle = this.circles[i].color;
                this.ctx.arc(this.circles[i].center.x, this.circles[i].center.y, this.circles[i].radius, 0, 2 * Math.PI);
                this.ctx.moveTo(this.circles[i].center.x, this.circles[i].center.y);
                this.ctx.lineTo(this.circles[i].intersect.x, this.circles[i].intersect.y);
                this.ctx.moveTo(this.circles[i].intersect.x, this.circles[i].intersect.y);
                this.ctx.lineTo(this.boundary, this.circles[i].intersect.y);
                for (var j = 0; j < this.circles[i].curve.length; j ++) {
                    this.ctx.fillRect(this.circles[i].curve[j].x, this.circles[i].curve[j].y, 1, 1);
                }
                this.ctx.stroke();
            }
        },
        refresh : function(e) {
            if (this.pause) {
                return;
            }
            this.recompute();
            this.redraw();
        }        
    },
    mounted : function(){
        this.init();
        setInterval( this.refresh, 5000/360);
    }
})

</script>
